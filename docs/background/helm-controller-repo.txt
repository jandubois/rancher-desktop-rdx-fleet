Directory structure:
└── k3s-io-helm-controller/
    ├── README.md
    ├── crd-ref-docs.yaml
    ├── Dockerfile
    ├── kustomization.yaml
    ├── main.go
    ├── Makefile
    ├── doc/
    │   └── helmchart.md
    ├── manifests/
    │   ├── deployment.yaml
    │   ├── example-helmchart.yaml
    │   ├── ns.yaml
    │   └── rbac.yaml
    ├── scripts/
    │   ├── boilerplate.go.txt
    │   ├── e2e
    │   ├── package
    │   ├── test
    │   ├── validate
    │   └── version
    └── test/
        ├── framework/
        │   ├── controller.go
        │   └── framework.go
        └── suite/
            ├── helm_test.go
            └── zz_suite_test.go

================================================
FILE: README.md
================================================
helm-controller
========

A simple way to manage helm charts with Custom Resource Definitions in k8s.

## Manifests and Deploying
The `./manifests` folder contains useful YAML manifests to use for deploying and developing the Helm Controller. This simple YAML deployment creates a HelmChart CRD + a Deployment using the `rancher/helm-controller` container. The YAML might need some modifications for your environment so read below for Namespaced vs Cluster deployments and how to use them properly.

#### Namespaced Deploys
Use the `deploy-namespaced.yaml` to create a namespace and add the Helm Controller and CRD to that namespace locking down the Helm Controller to only see changes to CRDs within that namespace. This is defaulted to `helm-controller` so update the YAML to your needs before running `kubectl create`

#### Cluster Scoped Deploys
If you'd like your helm controller to watch the entire cluster for HelmChart CRD changes use the `deploy-cluster-scoped.yaml` deploy manifest. By default it will add the helm-controller to the `kube-system` so update `metadata.namespace` for your needs.

## API Documentation

Autogenerated API docs for `helm.cattle.io/v1 HelmChart` and `HelmChartConfig` are available at [doc/helmchart.md](doc/helmchart.md#HelmChart)

## Uninstalling
To remove the Helm Controller run `kubectl delete` and pass the deployment YAML used using to create the Deployment `-f` parameter.

## Developing and Building
The Helm Controller is easy to get running locally, follow the instructions for your needs and requires a running k8s server + CRDs etc. When you have a working k8s cluster, you can use `./manifests/crd.yaml` to create the CRD and `./manifests/example-helmchart.yaml` which runs the `stable/traefik` helm chart.

#### Locally
Building and running natively will start a daemon which will watch a local k8s API. See Manifests section above about how to create the CRD and Objects using the provided manifests.

```
go build -o ./bin/helm-controller
./bin/helm-controller --kubeconfig $HOME/.kube/config
```

#### docker/k8s
An easy way to get started with docker/k8s is to install docker for windows/mac and use the included k8s cluster. Once functioning you can easily build locally and get a docker container to pull the Helm Controller container and run it in k8s. Use `make` to launch a Linux container and build to create a container. Use the `./manifests/deploy-*.yaml` definitions to get it into your cluster and update  `containers.image` to point to your locally image e.g. `image: rancher/helm-controller:dev`

#### Options and Usage
Use `./bin/helm-controller help` to get full usage details. The outside of a k8s Pod the most important options are `--kubeconfig` or `--masterurl` or it will not run. All options have corresponding ENV variables you could use.

## Testing
`go test ./...`

## License
Copyright (c) 2019 [Rancher Labs, Inc.](http://rancher.com)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

[http://www.apache.org/licenses/LICENSE-2.0](http://www.apache.org/licenses/LICENSE-2.0)

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.



================================================
FILE: crd-ref-docs.yaml
================================================
processor:
  ignoreFields:
    - "TypeMeta$"
render:
  kubernetesVersion: 1.32



================================================
FILE: Dockerfile
================================================
FROM golang:1.24-alpine3.22 AS builder

RUN apk add --no-cache bash git gcc musl-dev

WORKDIR /src
COPY . .

RUN --mount=type=cache,id=gomod,target=/go/pkg/mod \
    --mount=type=cache,id=gobuild,target=/root/.cache/go-build \
    ./scripts/build

FROM scratch AS binary
COPY --from=builder /src/bin/helm-controller /bin/

# Dev stage for package, testing, and validation
FROM golang:1.24-alpine3.22 AS dev
ARG ARCH
ENV ARCH=$ARCH
RUN apk add --no-cache bash git gcc musl-dev curl
RUN GOPROXY=direct go install golang.org/x/tools/cmd/goimports@gopls/v0.18.1
RUN GOPROXY=direct go install sigs.k8s.io/controller-tools/cmd/controller-gen@v0.17.3
RUN if [ "${ARCH}" != "arm" ]; then \
    curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s v1.64.7; \
    fi
RUN if [ "${ARCH}" = "amd64" ]; then \
    go install sigs.k8s.io/kustomize/kustomize/v5@v5.6.0; \
    fi

WORKDIR /src
COPY go.mod go.sum pkg/ main.go ./
RUN go mod download
COPY . .

FROM dev AS package
RUN ./scripts/package

FROM scratch AS artifacts
COPY --from=package /src/dist/artifacts /dist/artifacts

FROM alpine:3.22 AS production
COPY bin/helm-controller /usr/bin/
CMD ["helm-controller"]



================================================
FILE: kustomization.yaml
================================================
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
sortOptions:
  order: fifo
resources:
- manifests/crd.yaml
- manifests/ns.yaml
- manifests/rbac.yaml
- manifests/deployment.yaml
images:
- name: rancher/helm-controller
  newTag: v0.12.1



================================================
FILE: main.go
================================================
//go:generate go run pkg/codegen/cleanup/main.go
//go:generate rm -rf pkg/generated pkg/crds/yaml/generated
//go:generate go run pkg/codegen/main.go
//go:generate controller-gen crd:generateEmbeddedObjectMeta=true paths=./pkg/apis/... output:crd:dir=./pkg/crds/yaml/generated
//go:generate crd-ref-docs --config=crd-ref-docs.yaml --renderer=markdown --output-path=doc/helmchart.md

package main

import (
	_ "net/http/pprof"
	"os"

	"github.com/k3s-io/helm-controller/pkg/cmd"
	"github.com/k3s-io/helm-controller/pkg/version"
	_ "github.com/rancher/wrangler/v3/pkg/generated/controllers/apiextensions.k8s.io"
	_ "github.com/rancher/wrangler/v3/pkg/generated/controllers/networking.k8s.io"
	"github.com/rancher/wrangler/v3/pkg/signals"
	"github.com/sirupsen/logrus"
	"github.com/urfave/cli/v2"
)

var config = cmd.HelmController{}

func main() {
	app := &cli.App{
		Name:        "helm-controller",
		Description: "A simple way to manage helm charts with CRDs in K8s.",
		Version:     version.FriendlyVersion(),
		Action: func(app *cli.Context) error {
			return config.Run(app)
		},
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:        "controller-name",
				Value:       "helm-controller",
				Usage:       "Unique name to identify this controller that is added to all HelmCharts tracked by this controller",
				EnvVars:     []string{"CONTROLLER_NAME"},
				Destination: &config.ControllerName,
			},
			&cli.BoolFlag{
				Name:        "debug",
				Usage:       "Turn on debug logging",
				Destination: &config.Debug,
			},
			&cli.IntFlag{
				Name:        "debug-level",
				Usage:       "If debugging is enabled, set klog -v=X",
				Destination: &config.DebugLevel,
			},
			&cli.StringFlag{
				Name:        "default-job-image",
				Usage:       "Default image to use by jobs managing helm charts",
				EnvVars:     []string{"DEFAULT_JOB_IMAGE"},
				Destination: &config.DefaultJobImage,
			},
			&cli.StringFlag{
				Name:        "job-cluster-role",
				Value:       "cluster-admin",
				Usage:       "Name of the cluster role to use for jobs created to manage helm charts",
				EnvVars:     []string{"JOB_CLUSTER_ROLE"},
				Destination: &config.JobClusterRole,
			},
			&cli.StringFlag{
				Name:        "kubeconfig",
				Usage:       "Kubernetes config files, e.g. $HOME/.kube/config",
				EnvVars:     []string{"KUBECONFIG"},
				Destination: &config.Kubeconfig,
			},
			&cli.StringFlag{
				Name:        "master-url",
				Usage:       "Kubernetes cluster master URL",
				EnvVars:     []string{"MASTERURL"},
				Destination: &config.MasterURL,
			},
			&cli.StringFlag{
				Name:        "namespace",
				Usage:       "Namespace to watch, empty means it will watch CRDs in all namespaces",
				EnvVars:     []string{"NAMESPACE"},
				Destination: &config.Namespace,
			},
			&cli.StringFlag{
				Name:        "node-name",
				Usage:       "Name of the node this controller is running on",
				EnvVars:     []string{"NODE_NAME"},
				Destination: &config.NodeName,
			},
			&cli.IntFlag{
				Name:        "pprof-port",
				Value:       6060,
				Usage:       "Port to publish HTTP server runtime profiling data in the format expected by the pprof visualization tool. Only enabled if in debug mode",
				Destination: &config.PprofPort,
			},
			&cli.IntFlag{
				Name:        "threads",
				Value:       2,
				Usage:       "Threadiness level to set",
				EnvVars:     []string{"THREADS"},
				Destination: &config.Threads,
			},
		},
	}

	ctx := signals.SetupSignalContext()
	if err := app.RunContext(ctx, os.Args); err != nil {
		logrus.Fatal(err)
	}
}



================================================
FILE: Makefile
================================================
IMAGE_NAME ?= helm-controller
ARCH ?= amd64

.DEFAULT_GOAL := ci
.PHONY: build test validate package clean

build:
	DOCKER_BUILDKIT=1 docker build \
		--target binary \
		--output type=local,dest=. .

validate:
	docker build --target dev --build-arg ARCH=$(ARCH) -t $(IMAGE_NAME)-dev .
	docker run --rm $(IMAGE_NAME)-dev ./scripts/validate

test:
	docker build --target dev --build-arg ARCH=$(ARCH) -t $(IMAGE_NAME)-dev .
	docker run --rm $(IMAGE_NAME)-dev ./scripts/test

package: SHELL:=/bin/bash
package: 
	docker build --target artifacts --build-arg ARCH=$(ARCH) --output type=local,dest=. .
	source ./scripts/version &&	IMAGE=$${REPO}/helm-controller:$${TAG}; \
		docker build -t $${IMAGE} --target production .; \
		echo $${IMAGE} > bin/helm-controller-image.txt; \
		echo Built $${IMAGE}

clean:
	rm -rf bin dist

ci: build validate test package



================================================
FILE: doc/helmchart.md
================================================
# API Reference

## Packages
- [helm.cattle.io/v1](#helmcattleiov1)


## helm.cattle.io/v1






#### FailurePolicy

_Underlying type:_ _string_



_Validation:_
- Enum: [abort reinstall]

_Appears in:_
- [HelmChartConfigSpec](#helmchartconfigspec)
- [HelmChartSpec](#helmchartspec)



#### HelmChart



HelmChart represents configuration and state for the deployment of a Helm chart.



_Appears in:_
- [HelmChartList](#helmchartlist)

| Field | Description | Default | Validation |
| --- | --- | --- | --- |
| `metadata` _[ObjectMeta](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.32/#objectmeta-v1-meta)_ | Refer to Kubernetes API documentation for fields of `metadata`. |  |  |
| `spec` _[HelmChartSpec](#helmchartspec)_ |  |  |  |
| `status` _[HelmChartStatus](#helmchartstatus)_ |  |  |  |


#### HelmChartCondition







_Appears in:_
- [HelmChartStatus](#helmchartstatus)

| Field | Description | Default | Validation |
| --- | --- | --- | --- |
| `type` _[HelmChartConditionType](#helmchartconditiontype)_ | Type of job condition. |  |  |
| `status` _[ConditionStatus](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.32/#conditionstatus-v1-core)_ | Status of the condition, one of True, False, Unknown. |  |  |
| `reason` _string_ | (brief) reason for the condition's last transition. |  |  |
| `message` _string_ | Human readable message indicating details about last transition. |  |  |


#### HelmChartConditionType

_Underlying type:_ _string_





_Appears in:_
- [HelmChartCondition](#helmchartcondition)

| Field | Description |
| --- | --- |
| `JobCreated` |  |
| `Failed` |  |


#### HelmChartConfig



HelmChartConfig represents additional configuration for the installation of Helm chart release.
This resource is intended for use when additional configuration needs to be passed to a HelmChart
that is managed by an external system.



_Appears in:_
- [HelmChartConfigList](#helmchartconfiglist)

| Field | Description | Default | Validation |
| --- | --- | --- | --- |
| `metadata` _[ObjectMeta](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.32/#objectmeta-v1-meta)_ | Refer to Kubernetes API documentation for fields of `metadata`. |  |  |
| `spec` _[HelmChartConfigSpec](#helmchartconfigspec)_ |  |  |  |




#### HelmChartConfigSpec



HelmChartConfigSpec represents additional user-configurable details of an installed and configured Helm chart release.
These fields are merged with or override the corresponding fields on the related HelmChart resource.



_Appears in:_
- [HelmChartConfig](#helmchartconfig)

| Field | Description | Default | Validation |
| --- | --- | --- | --- |
| `valuesContent` _string_ | Override complex Chart values via inline YAML content.<br />Helm CLI positional argument/flag: `--values` |  |  |
| `valuesSecrets` _[SecretSpec](#secretspec) array_ | Override complex Chart values via references to external Secrets.<br />Helm CLI positional argument/flag: `--values` |  |  |
| `failurePolicy` _[FailurePolicy](#failurepolicy)_ | Configures handling of failed chart installation or upgrades.<br />- `reinstall` will perform a clean uninstall and reinstall of the chart.<br />- `abort` will take no action and leave the chart in a failed state so that the administrator can manually resolve the error. | reinstall | Enum: [abort reinstall] <br /> |




#### HelmChartSpec



HelmChartSpec represents the user-configurable details for installation and upgrade of a Helm chart release.



_Appears in:_
- [HelmChart](#helmchart)

| Field | Description | Default | Validation |
| --- | --- | --- | --- |
| `targetNamespace` _string_ | Helm Chart target namespace.<br />Helm CLI positional argument/flag: `--namespace` |  |  |
| `createNamespace` _boolean_ | Create target namespace if not present.<br />Helm CLI positional argument/flag: `--create-namespace` |  |  |
| `chart` _string_ | Helm Chart name in repository, or complete HTTPS URL to chart archive (.tgz)<br />Helm CLI positional argument/flag: `CHART` |  |  |
| `version` _string_ | Helm Chart version. Only used when installing from repository; ignored when .spec.chart or .spec.chartContent is used to install a specific chart archive.<br />Helm CLI positional argument/flag: `--version` |  |  |
| `repo` _string_ | Helm Chart repository URL.<br />Helm CLI positional argument/flag: `--repo` |  |  |
| `repoCA` _string_ | Verify certificates of HTTPS-enabled servers using this CA bundle. Should be a string containing one or more PEM-encoded CA Certificates.<br />Helm CLI positional argument/flag: `--ca-file` |  |  |
| `repoCAConfigMap` _[LocalObjectReference](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.32/#localobjectreference-v1-core)_ | Reference to a ConfigMap containing CA Certificates to be be trusted by Helm. Can be used along with or instead of `.spec.repoCA`<br />Helm CLI positional argument/flag: `--ca-file` |  |  |
| `set` _object (keys:string, values:[IntOrString](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.32/#intorstring-intstr-util))_ | Override simple Chart values. These take precedence over options set via valuesContent.<br />Helm CLI positional argument/flag: `--set`, `--set-string` |  |  |
| `valuesContent` _string_ | Override complex Chart values via inline YAML content.<br />Helm CLI positional argument/flag: `--values` |  |  |
| `valuesSecrets` _[SecretSpec](#secretspec) array_ | Override complex Chart values via references to external Secrets.<br />Helm CLI positional argument/flag: `--values` |  |  |
| `helmVersion` _string_ | DEPRECATED. Helm version to use. Only v3 is currently supported. |  |  |
| `bootstrap` _boolean_ | Set to True if this chart is needed to bootstrap the cluster (Cloud Controller Manager, CNI, etc). |  |  |
| `takeOwnership` _boolean_ | Set to True if helm should take ownership of existing resources when installing/upgrading the chart.<br />Helm CLI positional argument/flag: `--take-ownership` |  |  |
| `chartContent` _string_ | Base64-encoded chart archive .tgz; overides `.spec.chart` and `.spec.version`.<br />Helm CLI positional argument/flag: `CHART` |  |  |
| `jobImage` _string_ | Specify the image to use for tht helm job pod when installing or upgrading the helm chart. |  |  |
| `backOffLimit` _integer_ | Specify the number of retries before considering the helm job failed. |  |  |
| `timeout` _[Duration](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.32/#duration-v1-meta)_ | Timeout for Helm operations.<br />Helm CLI positional argument/flag: `--timeout` |  |  |
| `failurePolicy` _[FailurePolicy](#failurepolicy)_ | Configures handling of failed chart installation or upgrades.<br />- `reinstall` will perform a clean uninstall and reinstall of the chart.<br />- `abort` will take no action and leave the chart in a failed state so that the administrator can manually resolve the error. | reinstall | Enum: [abort reinstall] <br /> |
| `authSecret` _[LocalObjectReference](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.32/#localobjectreference-v1-core)_ | Reference to Secret of type kubernetes.io/basic-auth holding Basic auth credentials for the Chart repo. |  |  |
| `authPassCredentials` _boolean_ | Pass Basic auth credentials to all domains.<br />Helm CLI positional argument/flag: `--pass-credentials` |  |  |
| `insecureSkipTLSVerify` _boolean_ | Skip TLS certificate checks for the chart download.<br />Helm CLI positional argument/flag: `--insecure-skip-tls-verify` |  |  |
| `plainHTTP` _boolean_ | Use insecure HTTP connections for the chart download.<br />Helm CLI positional argument/flag: `--plain-http` |  |  |
| `dockerRegistrySecret` _[LocalObjectReference](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.32/#localobjectreference-v1-core)_ | Reference to Secret of type kubernetes.io/dockerconfigjson holding Docker auth credentials for the OCI-based registry acting as the Chart repo. |  |  |
| `podSecurityContext` _[PodSecurityContext](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.32/#podsecuritycontext-v1-core)_ | Custom PodSecurityContext for the helm job pod. |  |  |
| `securityContext` _[SecurityContext](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.32/#securitycontext-v1-core)_ | custom SecurityContext for the helm job pod. |  |  |


#### HelmChartStatus



HelmChartStatus represents the resulting state from processing HelmChart events



_Appears in:_
- [HelmChart](#helmchart)

| Field | Description | Default | Validation |
| --- | --- | --- | --- |
| `jobName` _string_ | The name of the job created to install or upgrade the chart. |  |  |
| `conditions` _[HelmChartCondition](#helmchartcondition) array_ | `JobCreated` indicates that a job has been created to install or upgrade the chart.<br />`Failed` indicates that the helm job has failed and the failure policy is set to `abort`. |  |  |


#### SecretSpec



SecretSpec describes a key in a secret to load chart values from.



_Appears in:_
- [HelmChartConfigSpec](#helmchartconfigspec)
- [HelmChartSpec](#helmchartspec)

| Field | Description | Default | Validation |
| --- | --- | --- | --- |
| `name` _string_ | Name of the secret. Must be in the same namespace as the HelmChart resource. |  |  |
| `keys` _string array_ | Keys to read values content from. If no keys are specified, the secret is not used. |  |  |
| `ignoreUpdates` _boolean_ | Ignore changes to the secret, and mark the secret as optional.<br />By default, the secret must exist, and changes to the secret will trigger an upgrade of the chart to apply the updated values.<br />If `ignoreUpdates` is true, the secret is optional, and changes to the secret will not trigger an upgrade of the chart. |  |  |





================================================
FILE: manifests/deployment.yaml
================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: helm-controller
  namespace: helm-controller
  labels:
    app: helm-controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app: helm-controller
  template:
    metadata:
      labels:
        app: helm-controller
    spec:
      serviceAccountName: helm-controller
      containers:
      - name: helm-controller
        image: rancher/helm-controller:v0.12.1
        command: ["helm-controller"]
        env:
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: JOB_CLUSTER_ROLE
          valueFrom:
            fieldRef:
              fieldPath: spec.serviceAccountName



================================================
FILE: manifests/example-helmchart.yaml
================================================
apiVersion: helm.cattle.io/v1
kind: HelmChart
metadata:
  name: traefik 
  namespace: kube-system
spec:
  chart: stable/traefik
  set:
    rbac.enabled: "true"
    ssl.enabled: "true"




================================================
FILE: manifests/ns.yaml
================================================
apiVersion: v1
kind: Namespace
metadata:
  name: helm-controller
  labels:
    name: helm-controller



================================================
FILE: manifests/rbac.yaml
================================================
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: helm-controller
rules:
- apiGroups:
  - "*"
  resources:
  - "*"
  verbs:
  - "*"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: helm-controller
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: helm-controller
subjects:
- kind: ServiceAccount
  name: helm-controller
  namespace: helm-controller
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: helm-controller
  namespace: helm-controller



================================================
FILE: scripts/boilerplate.go.txt
================================================
/*
Copyright The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/




================================================
FILE: scripts/e2e
================================================
#!/bin/bash
set -ex

K3S_WAIT_TIME=15
K3S_NODE_NAME=helmtest-node1
K3S_VERSION=v1.30.2-k3s2

cd $(dirname $0)/..

if [[ ! -f 'bin/helm-controller-image.txt' ]]; then
    echo "Run 'make package' first."
    exit 1
fi

setup_k8s(){
    # Drone launches each step in an isolated network. Check and see if there is another bridge network
    # that is not the default bridge network. If so, use that network for the k3s node.
    BRIDGE_NETWORKS=$(docker network ls --filter driver=bridge --format '{{.Name}}' | grep -v bridge || true)
    if [ -n "$BRIDGE_NETWORKS" ]; then
        K3S_NODE_NETWORK=$(echo "$BRIDGE_NETWORKS" | head -n 1)
        echo "Using network $K3S_NODE_NETWORK"
    else
        K3S_NODE_NETWORK=bridge
    fi
    # Using k3s with embedded helm controller disabled
    docker pull rancher/k3s:$K3S_VERSION
    docker run --detach --privileged --rm --network="$K3S_NODE_NETWORK" -p 6443 --name $K3S_NODE_NAME --hostname $K3S_NODE_NAME rancher/k3s:$K3S_VERSION server --disable-helm-controller --disable=metrics-server,traefik
    K3S_NODE_IP=$(docker inspect $K3S_NODE_NAME --format="{{index .NetworkSettings.Networks \"$K3S_NODE_NETWORK\" \"IPAddress\"}}")
    sleep $K3S_WAIT_TIME
    docker exec $K3S_NODE_NAME sed "s/127.0.0.1/$K3S_NODE_IP/" /etc/rancher/k3s/k3s.yaml > $PWD/kube_config_cluster.yml
}

teardown_k8s(){
    docker rm -f $K3S_NODE_NAME
}

load_helm_image(){
    docker image save $HELM_CONTROLLER_IMAGE | docker exec -i $K3S_NODE_NAME ctr --namespace k8s.io image import -
}

trap teardown_k8s EXIT
setup_k8s
export KUBECONFIG=$PWD/kube_config_cluster.yml
export HELM_CONTROLLER_IMAGE=$(cat bin/helm-controller-image.txt)
load_helm_image
go test -cover -tags=test -v ./test/...



================================================
FILE: scripts/package
================================================
#!/bin/bash
set -e

source $(dirname $0)/version

cd $(dirname $0)/..

if [[ ! -f 'bin/helm-controller' ]]; then
    echo "Run 'make build' first."
    exit 1
fi

mkdir -p dist/artifacts
cp bin/helm-controller dist/artifacts/helm-controller${SUFFIX}

reset-kustomization() {
  git checkout kustomization.yaml
}

if [ "$ARCH" = "amd64" ]; then
  trap reset-kustomization EXIT
  cat ./pkg/crds/yaml/*/* > manifests/crd.yaml
  kustomize edit set image "rancher/helm-controller=${REPO}/helm-controller:${VERSION}"
  kustomize build > ./dist/artifacts/deploy-cluster-scoped.yaml

  cat <<EOF >> kustomization.yaml
patches:
  - patch: |- 
      apiVersion: apps/v1
      kind: Deployment
      metadata:
        name: helm-controller
        namespace: helm-controller
      spec:
        template:
          spec:
            containers:
            - name: helm-controller
              env:
              - name: NAMESPACE
                valueFrom:
                  fieldRef:
                    fieldPath: metadata.namespace
EOF
  kustomize build > ./dist/artifacts/deploy-namespaced.yaml
fi



================================================
FILE: scripts/test
================================================
#!/bin/bash
set -e

cd $(dirname $0)/..

echo Running tests
go test ./pkg/... -cover -tags=test



================================================
FILE: scripts/validate
================================================
#!/bin/bash
set -e

cd $(dirname $0)/..

if ! command -v golangci-lint; then
    echo Skipping validation: no golangci-lint available
    exit
fi

echo Running validation

echo Running: golangci-lint
golangci-lint run

echo Running: go fmt
test -z "$(go fmt ${PACKAGES} | tee /dev/stderr)"



================================================
FILE: scripts/version
================================================
#!/bin/bash

ARCH=${ARCH:-$(go env GOHOSTARCH)}
SUFFIX="-${ARCH}"

if [ -n "$(git status --porcelain --untracked-files=no)" ]; then
    DIRTY="-dirty"
fi

COMMIT=$(git rev-parse --short HEAD)
GIT_TAG=${DRONE_TAG:-$(git tag -l --contains HEAD | head -n 1)}

if [[ -z "$DIRTY" && -n "$GIT_TAG" ]]; then
    VERSION=$GIT_TAG
else
    VERSION="${COMMIT}${DIRTY}"
fi

# For docker image
TAG=${TAG:-${VERSION}${SUFFIX}}
REPO=${REPO:-rancher}

# If tag contains dirty, set to dev
if echo $TAG | grep -q dirty; then
    TAG=dev
fi



================================================
FILE: test/framework/controller.go
================================================
package framework

import (
	"context"
	"os"
	"time"

	"github.com/k3s-io/helm-controller/pkg/controllers/chart"
	"github.com/rancher/wrangler/v3/pkg/crd"
	"github.com/sirupsen/logrus"
	v1 "k8s.io/api/rbac/v1"
	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/util/wait"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

func (f *Framework) setupController(ctx context.Context) error {
	_, err := f.ClientSet.CoreV1().Namespaces().Create(ctx, f.getNS(), metav1.CreateOptions{})
	if err != nil {
		return err
	}

	_, err = f.ClientSet.RbacV1().ClusterRoles().Create(ctx, f.getCr(), metav1.CreateOptions{})
	if err != nil {
		return err
	}

	_, err = f.ClientSet.RbacV1().ClusterRoleBindings().Create(ctx, f.getCrb(), metav1.CreateOptions{})
	if err != nil {
		return err
	}

	if err := crd.BatchCreateCRDs(ctx, f.ClientExt.ApiextensionsV1().CustomResourceDefinitions(), nil, time.Minute, f.crds); err != nil {
		return err
	}

	_, err = f.ClientSet.CoreV1().ServiceAccounts(f.Namespace).Create(ctx, f.getSa(), metav1.CreateOptions{})
	if err != nil {
		return err
	}

	err = wait.Poll(time.Second, 15*time.Second, func() (bool, error) {
		_, err := f.ClientSet.CoreV1().ServiceAccounts(f.Namespace).Get(ctx, f.Name, metav1.GetOptions{})
		if err == nil {
			return true, nil
		}

		if errors.IsNotFound(err) {
			return false, nil
		}

		logrus.Printf("Waiting for SA to be ready: %+v\n", err)
		return false, err
	})
	if err != nil {
		return err
	}

	_, err = f.ClientSet.AppsV1().Deployments(f.Namespace).Create(context.TODO(), f.getDeployment(), metav1.CreateOptions{})
	return err
}

func (f *Framework) getNS() *corev1.Namespace {
	return &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name:      f.Name,
			Namespace: f.Namespace,
		},
	}
}

func (f *Framework) getDeployment() *appsv1.Deployment {
	return &appsv1.Deployment{
		ObjectMeta: metav1.ObjectMeta{
			Name:      f.Name,
			Namespace: f.Namespace,
			Labels: map[string]string{
				"app": f.Name,
			},
		},
		Spec: appsv1.DeploymentSpec{
			Selector: &metav1.LabelSelector{
				MatchLabels: map[string]string{
					"app": f.Name,
				},
			},
			Template: corev1.PodTemplateSpec{
				ObjectMeta: metav1.ObjectMeta{
					Labels: map[string]string{
						"app": f.Name,
					},
				},
				Spec: corev1.PodSpec{
					ServiceAccountName: f.Name,
					Containers: []corev1.Container{
						{
							Name:    f.Name,
							Image:   getImage(),
							Command: []string{"helm-controller"},
							Args: []string{
								"--namespace", "helm-controller",
								"--job-cluster-role", f.Name,
							},
						},
					},
				},
			},
		},
	}
}

func getImage() string {
	if img, ok := os.LookupEnv("HELM_CONTROLLER_IMAGE"); ok {
		return img
	}
	return "rancher/helm-controller:latest"
}

func (f *Framework) getCr() *v1.ClusterRole {
	return &v1.ClusterRole{
		ObjectMeta: metav1.ObjectMeta{
			Name: f.Name,
		},
		Rules: []v1.PolicyRule{
			{
				APIGroups: []string{"*"},
				Resources: []string{"*"},
				Verbs:     []string{"*"},
			},
			{
				NonResourceURLs: []string{"*"},
				Verbs:           []string{"*"},
			},
		},
	}
}

func (f *Framework) getCrb() *v1.ClusterRoleBinding {
	return &v1.ClusterRoleBinding{
		ObjectMeta: metav1.ObjectMeta{
			Name: f.Name,
		},
		RoleRef: v1.RoleRef{
			APIGroup: "rbac.authorization.k8s.io",
			Kind:     "ClusterRole",
			Name:     f.Name,
		},
		Subjects: []v1.Subject{
			{
				Kind:      "ServiceAccount",
				Name:      f.Name,
				Namespace: f.Namespace,
			},
		},
	}
}

func (f *Framework) getSa() *corev1.ServiceAccount {
	return &corev1.ServiceAccount{
		ObjectMeta: metav1.ObjectMeta{
			Name:      f.Name,
			Namespace: f.Namespace,
		},
	}
}

func (f *Framework) teardownController(ctx context.Context) error {
	charts, err := f.ListHelmCharts("helm-test=true", f.Namespace)
	if err != nil {
		return err
	}
	for _, item := range charts.Items {
		// refresh object before updating; it may have changed since listing
		rItem, err := f.GetHelmChart(item.Name, item.Namespace)
		if err != nil {
			return err
		}

		rItem.Finalizers = []string{}
		_, err = f.UpdateHelmChart(rItem, f.Namespace)
		if err != nil {
			return err
		}

		err = f.DeleteHelmChart(item.Name, item.Namespace)
		if err != nil && !errors.IsNotFound(err) {
			return err
		}
	}

	err = f.ClientSet.RbacV1().ClusterRoleBindings().Delete(ctx, f.Name, metav1.DeleteOptions{})
	if err != nil && !errors.IsNotFound(err) {
		return err
	}

	err = f.ClientExt.ApiextensionsV1().CustomResourceDefinitions().Delete(ctx, chart.CRDName, metav1.DeleteOptions{})
	if err != nil && !errors.IsNotFound(err) {
		return err
	}

	err = f.ClientSet.CoreV1().Namespaces().Delete(ctx, f.Namespace, metav1.DeleteOptions{})
	if err != nil && !errors.IsNotFound(err) {
		return err
	}

	return nil
}



================================================
FILE: test/framework/framework.go
================================================
package framework

import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"io"
	"net/http"
	"os"

	"k8s.io/client-go/util/retry"

	v1 "github.com/k3s-io/helm-controller/pkg/apis/helm.cattle.io/v1"
	"github.com/k3s-io/helm-controller/pkg/controllers/common"
	helmcrd "github.com/k3s-io/helm-controller/pkg/crds"
	helmcln "github.com/k3s-io/helm-controller/pkg/generated/clientset/versioned"
	"github.com/onsi/ginkgo/v2"
	"github.com/rancher/wrangler/v3/pkg/condition"
	"github.com/sirupsen/logrus"
	batchv1 "k8s.io/api/batch/v1"
	corev1 "k8s.io/api/core/v1"
	apiextv1 "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	extclient "k8s.io/apiextensions-apiserver/pkg/client/clientset/clientset"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
)

var (
	conditionComplete = condition.Cond(batchv1.JobComplete)
	conditionFailed   = condition.Cond(batchv1.JobFailed)
)

type Framework struct {
	HelmClientSet *helmcln.Clientset
	ClientSet     *kubernetes.Clientset
	ClientExt     *extclient.Clientset
	crds          []*apiextv1.CustomResourceDefinition
	Kubeconfig    string
	Name          string
	Namespace     string
	PID           int
}

func New() (*Framework, error) {
	framework := &Framework{}
	ginkgo.BeforeAll(framework.BeforeAll)
	ginkgo.AfterAll(framework.AfterAll)
	return framework, nil
}

func (f *Framework) BeforeAll() {
	f.beforeFramework()
	err := f.setupController(context.TODO())
	if err != nil {
		errExit("Failed to set up helm controller", err)
	}
}

func (f *Framework) AfterAll() {
	if ginkgo.CurrentSpecReport().Failed() {
		podList, _ := f.ClientSet.CoreV1().Pods(f.Namespace).List(context.Background(), metav1.ListOptions{})
		for _, pod := range podList.Items {
			containerNames := []string{}
			for _, container := range pod.Spec.InitContainers {
				containerNames = append(containerNames, container.Name)
			}
			for _, container := range pod.Spec.Containers {
				containerNames = append(containerNames, container.Name)
			}
			for _, container := range containerNames {
				reportName := fmt.Sprintf("podlogs-%s-%s", pod.Name, container)
				logs := f.ClientSet.CoreV1().Pods(f.Namespace).GetLogs(pod.Name, &corev1.PodLogOptions{Container: container})
				if logStreamer, err := logs.Stream(context.Background()); err == nil {
					if podLogs, err := io.ReadAll(logStreamer); err == nil {
						ginkgo.AddReportEntry(reportName, string(podLogs))
					}
				}
			}
		}
	}
	if err := f.teardownController(context.TODO()); err != nil {
		errExit("Failed to teardown helm controller", err)
	}
}

func (f *Framework) beforeFramework() {
	ginkgo.By("Creating a kubernetes client")
	f.Kubeconfig = os.Getenv("KUBECONFIG")
	config, err := clientcmd.BuildConfigFromFlags("", f.Kubeconfig)
	errExit("Failed to build a rest config from file", err)
	helmcln, err := helmcln.NewForConfig(config)
	errExit("Failed to initiate helm client", err)
	clientset, err := kubernetes.NewForConfig(config)
	errExit("Failed to initiate a client set", err)
	clientext, err := extclient.NewForConfig(config)
	errExit("Failed to initiate a extension-apiserver client set", err)
	f.crds, err = helmcrd.List()
	errExit("Failed to construct helm crds", err)

	f.HelmClientSet = helmcln
	f.ClientSet = clientset
	f.ClientExt = clientext
	f.Name = common.Name
	f.Namespace = common.Name

}

func errExit(msg string, err error) {
	if err == nil {
		return
	}
	logrus.Panicf("%s: %v", msg, err)
}

func (f *Framework) NewHelmChart(name, chart, version, helmVersion, valuesContent string, set map[string]intstr.IntOrString) *v1.HelmChart {
	return &v1.HelmChart{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: f.Namespace,
			Labels: map[string]string{
				"helm-test": "true",
			},
		},
		Spec: v1.HelmChartSpec{
			Chart:         chart,
			Version:       version,
			Repo:          "",
			ValuesContent: valuesContent,
			Set:           set,
			HelmVersion:   helmVersion,
		},
	}
}

func (f *Framework) NewHelmChartConfig(name, valuesContent string) *v1.HelmChartConfig {
	return &v1.HelmChartConfig{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name,
			Namespace: f.Namespace,
			Labels: map[string]string{
				"helm-test": "true",
			},
		},
		Spec: v1.HelmChartConfigSpec{
			ValuesContent: valuesContent,
		},
	}
}

func (f *Framework) ListReleases(chart *v1.HelmChart) ([]corev1.Secret, error) {
	labelSelector := labels.SelectorFromSet(labels.Set{
		"owner": "helm",
		"name":  chart.Name,
	})
	namespace := chart.Namespace
	if chart.Spec.TargetNamespace != "" {
		namespace = chart.Spec.TargetNamespace
	}

	secretList, err := f.ClientSet.CoreV1().Secrets(namespace).List(context.TODO(), metav1.ListOptions{LabelSelector: labelSelector.String()})

	if err != nil {
		if apierrors.IsNotFound(err) {
			return nil, nil
		}
		return nil, err
	}

	return secretList.Items, nil
}

func (f *Framework) CreateHelmChart(chart *v1.HelmChart, namespace string) (*v1.HelmChart, error) {
	return f.HelmClientSet.HelmV1().HelmCharts(namespace).Create(context.TODO(), chart, metav1.CreateOptions{})
}

func (f *Framework) UpdateHelmChart(chart *v1.HelmChart, namespace string) (updated *v1.HelmChart, err error) {
	hcs := f.HelmClientSet.HelmV1()
	if err = retry.RetryOnConflict(retry.DefaultRetry, func() error {
		updated, err = hcs.HelmCharts(namespace).Get(context.TODO(), chart.Name, metav1.GetOptions{})
		if err != nil {
			return err
		}
		updated.Spec = chart.Spec
		_, err = hcs.HelmCharts(namespace).Update(context.TODO(), updated, metav1.UpdateOptions{})
		return err
	}); err != nil {
		updated = nil
	}
	return
}

func (f *Framework) DeleteHelmChart(name, namespace string) error {
	return f.HelmClientSet.HelmV1().HelmCharts(namespace).Delete(context.TODO(), name, metav1.DeleteOptions{})
}

func (f *Framework) GetHelmChart(name, namespace string) (*v1.HelmChart, error) {
	r, err := f.HelmClientSet.HelmV1().HelmCharts(namespace).Get(context.TODO(), name, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}
	return r, nil
}

func (f *Framework) ListHelmCharts(labelSelector, namespace string) (*v1.HelmChartList, error) {
	return f.HelmClientSet.HelmV1().HelmCharts(namespace).List(context.TODO(), metav1.ListOptions{
		LabelSelector: labelSelector,
	})
}

func (f *Framework) CreateHelmChartConfig(chartConfig *v1.HelmChartConfig, namespace string) (*v1.HelmChartConfig, error) {
	return f.HelmClientSet.HelmV1().HelmChartConfigs(namespace).Create(context.TODO(), chartConfig, metav1.CreateOptions{})
}

func (f *Framework) DeleteHelmChartConfig(name, namespace string) error {
	return f.HelmClientSet.HelmV1().HelmChartConfigs(namespace).Delete(context.TODO(), name, metav1.DeleteOptions{})
}

func (f *Framework) ListChartPods(chart *v1.HelmChart, appName string) ([]corev1.Pod, error) {
	labelSelector := labels.SelectorFromSet(labels.Set{
		"app":     appName,
		"release": chart.Name,
	})

	namespace := chart.Namespace
	if chart.Spec.TargetNamespace != "" {
		namespace = chart.Spec.TargetNamespace
	}

	podList, err := f.ClientSet.CoreV1().Pods(namespace).List(context.TODO(), metav1.ListOptions{LabelSelector: labelSelector.String()})

	if err != nil {
		if apierrors.IsNotFound(err) {
			return nil, nil
		}
		return nil, err
	}

	return podList.Items, nil
}

func (f *Framework) GetJob(chart *v1.HelmChart) (*batchv1.Job, error) {
	if chart.Status.JobName == "" {
		return nil, fmt.Errorf("waiting for job name to be populated")
	}
	r, err := f.ClientSet.BatchV1().Jobs(chart.Namespace).Get(context.TODO(), chart.Status.JobName, metav1.GetOptions{})
	if err != nil {
		return nil, err
	}
	return r, nil
}

// GetChartContent returns the base64-encoded chart tarball,
// downloaded from the specified URL.
func (f *Framework) GetChartContent(url string) (string, error) {
	resp, err := http.Get(url)
	if err != nil {
		return "", err
	}
	if resp.StatusCode != 200 {
		return "", fmt.Errorf("unexpected HTTP response: %s", resp.Status)
	}

	b := &bytes.Buffer{}
	w := base64.NewEncoder(base64.StdEncoding, b)
	if _, err := io.Copy(w, resp.Body); err != nil {
		return "", err
	}
	if err := w.Close(); err != nil {
		return "", err
	}
	return string(b.Bytes()), nil
}

// GetHelmChartCondition returns true if there is a condition on the chart matching the selected type, status, and reason
func (f *Framework) GetHelmChartCondition(chart *v1.HelmChart, condition v1.HelmChartConditionType, status corev1.ConditionStatus, reason string) bool {
	for _, v := range chart.Status.Conditions {
		if v.Type == condition && v.Status == status && v.Reason == reason {
			return true
		}
	}
	return false
}



================================================
FILE: test/suite/helm_test.go
================================================
package suite_test

import (
	"context"
	"fmt"
	"time"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	batchv1 "k8s.io/api/batch/v1"

	v1 "github.com/k3s-io/helm-controller/pkg/apis/helm.cattle.io/v1"
	"github.com/k3s-io/helm-controller/test/framework"
	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/utils/ptr"
)

var _ = Describe("HelmChart Controller Tests", Ordered, func() {
	framework, _ := framework.New()

	Context("When a HelmChart is created", func() {
		var (
			err   error
			chart *v1.HelmChart
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-example",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})

		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})

		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a HelmChart version is updated", func() {
		var (
			err   error
			chart *v1.HelmChart
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-update-example",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should create a new release when the version is changed", func() {
			chart, err = framework.GetHelmChart(chart.Name, chart.Namespace)
			chart.Spec.Version = "1.86.2"
			chart, err = framework.UpdateHelmChart(chart, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())
			Expect(chart.Spec.Version).To(Equal("1.86.2"))

			// check for 2 releases, and pod with image specified by new chart version
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(2))
			Eventually(framework.ListChartPods, 120*time.Second, 5*time.Second).WithArguments(chart, "traefik").Should(
				ContainElement(HaveField("Status.ContainerStatuses", ContainElements(HaveField("Image", ContainSubstring("docker.io/rancher/library-traefik:1.7.20"))))),
			)
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a HelmChart version is changed", func() {
		var (
			err   error
			chart *v1.HelmChart
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-update-example-values",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should create a new release when the values are changed", func() {
			chart, err = framework.GetHelmChart(chart.Name, chart.Namespace)
			chart.Spec.Set["replicas"] = intstr.FromString("3")
			chart, err = framework.UpdateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
			Expect(chart.Spec.Set["replicas"]).To(Equal(intstr.FromString("3")))

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(2))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a HelmChart is created with spec.takeOwnership=true", func() {
		var (
			err     error
			chart   *v1.HelmChart
			service *corev1.Service
		)
		BeforeAll(func() {
			service = &corev1.Service{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "traefik-example",
					Namespace: framework.Namespace,
				},
				Spec: corev1.ServiceSpec{
					ClusterIP: "None",
					Type:      corev1.ServiceTypeClusterIP,
				},
			}
			service, err = framework.ClientSet.CoreV1().Services(framework.Namespace).Create(context.TODO(), service, metav1.CreateOptions{})
			Expect(err).ToNot(HaveOccurred())

			chart = framework.NewHelmChart("traefik-example",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart.Spec.TakeOwnership = true
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})

		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})

		It("Should take ownership of existing resources", func() {
			Eventually(func(g Gomega) {
				service, err = framework.ClientSet.CoreV1().Services(framework.Namespace).Get(context.TODO(), service.Name, metav1.GetOptions{})
				g.Expect(err).ToNot(HaveOccurred())
				g.Expect(service).To(HaveField("ObjectMeta.Annotations", HaveKeyWithValue("meta.helm.sh/release-name", "traefik-example")))
			}, 120*time.Second, 5*time.Second).Should(Succeed())
		})

		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a HelmChart specifies a timeout", func() {
		var (
			err   error
			chart *v1.HelmChart
			job   *batchv1.Job
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-example-timeout",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart.Spec.Timeout = &metav1.Duration{Duration: time.Minute * 15}

			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should have the correct timeout", func() {
			chart, err = framework.GetHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			job, err = framework.GetJob(chart)
			Expect(err).ToNot(HaveOccurred())
			Expect(job.Spec.Template.Spec.Containers[0].Env).To(ContainElement(
				And(
					HaveField("Name", "TIMEOUT"),
					HaveField("Value", chart.Spec.Timeout.Duration.String()),
				),
			))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a HelmChart specifies ChartContent", func() {
		var (
			err   error
			chart *v1.HelmChart
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-example-chartcontent",
				"",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart.Spec.ChartContent, err = framework.GetChartContent("https://charts.helm.sh/stable/packages/traefik-1.86.1.tgz")
			Expect(err).ToNot(HaveOccurred())

			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a HelmChart has HelmChartConfig", func() {
		var (
			err         error
			chart       *v1.HelmChart
			chartConfig *v1.HelmChartConfig
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-example",
				"stable/traefik",
				"1.86.1",
				"v3",
				"",
				nil)
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should create a new release when the HelmChartConfig is created", func() {
			chartConfig = framework.NewHelmChartConfig(chart.Name, "metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n")
			chartConfig, err = framework.CreateHelmChartConfig(chartConfig, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(2))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			err = framework.DeleteHelmChartConfig(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a HelmChart has ValuesSecrets", func() {
		var (
			err        error
			chart      *v1.HelmChart
			userSecret *corev1.Secret
		)
		BeforeAll(func() {
			userSecret = &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "my-traefik-values",
					Namespace: framework.Namespace,
				},
				StringData: map[string]string{
					"values.yaml": "metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				},
			}
			userSecret, err = framework.ClientSet.CoreV1().Secrets(userSecret.Namespace).Create(context.TODO(), userSecret, metav1.CreateOptions{})
			Expect(err).ToNot(HaveOccurred())

			chart = framework.NewHelmChart("traefik-example",
				"stable/traefik",
				"1.86.1",
				"v3",
				"",
				nil)

			chart.Spec.ValuesSecrets = []v1.SecretSpec{
				{
					Name: userSecret.Name,
					Keys: []string{"values.yaml"},
				},
			}

			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should create a new release when the secret is modified", func() {
			userSecret.Data = nil
			userSecret.StringData = map[string]string{
				"values.yaml": "metrics:\n  prometheus:\n    enabled: false\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
			}
			userSecret, err = framework.ClientSet.CoreV1().Secrets(userSecret.Namespace).Update(context.TODO(), userSecret, metav1.UpdateOptions{})
			Expect(err).ToNot(HaveOccurred())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(2))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))

			err = framework.ClientSet.CoreV1().Secrets(userSecret.Namespace).Delete(context.TODO(), userSecret.Name, metav1.DeleteOptions{})
			Expect(err).ToNot(HaveOccurred())
		})
	})

	Context("When a HelmChart has HelmChartConfig ValuesSecrets", func() {
		var (
			err         error
			chart       *v1.HelmChart
			chartConfig *v1.HelmChartConfig
			userSecret  *corev1.Secret
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-example",
				"stable/traefik",
				"1.86.1",
				"v3",
				"",
				nil)
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should create a new release when the HelmChartConfig is created", func() {
			userSecret = &corev1.Secret{
				ObjectMeta: metav1.ObjectMeta{
					Name:      "my-traefik-values",
					Namespace: framework.Namespace,
				},
				StringData: map[string]string{
					"values.yaml": "metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				},
			}

			userSecret, err = framework.ClientSet.CoreV1().Secrets(userSecret.Namespace).Create(context.TODO(), userSecret, metav1.CreateOptions{})
			Expect(err).ToNot(HaveOccurred())

			chartConfig = framework.NewHelmChartConfig(chart.Name, "")
			chartConfig.Spec.ValuesSecrets = []v1.SecretSpec{
				{
					Name: userSecret.Name,
					Keys: []string{"values.yaml"},
				},
			}

			chartConfig, err = framework.CreateHelmChartConfig(chartConfig, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(2))
		})
		It("Should create a new release when the secret is modified", func() {
			userSecret.Data = nil
			userSecret.StringData = map[string]string{
				"values.yaml": "metrics:\n  prometheus:\n    enabled: false\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
			}
			userSecret, err = framework.ClientSet.CoreV1().Secrets(userSecret.Namespace).Update(context.TODO(), userSecret, metav1.UpdateOptions{})
			Expect(err).ToNot(HaveOccurred())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(3))
		})

		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			err = framework.DeleteHelmChartConfig(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})

	})

	Context("When a HelmChart creates a namespace", func() {
		var (
			err   error
			chart *v1.HelmChart
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-ns-example",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart.Spec.TargetNamespace = chart.Name
			chart.Spec.CreateNamespace = true
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart in the target namespace", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(
				And(
					HaveLen(1),
					ContainElement(HaveField("ObjectMeta.Namespace", Equal(chart.Spec.TargetNamespace))),
				))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a HelmChart V2 is created", func() {
		var (
			err   error
			chart *v1.HelmChart
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-example-v2",
				"stable/traefik",
				"1.86.1",
				"v2",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should have failed condition", func() {
			Eventually(func() error {
				chart, err = framework.GetHelmChart(chart.Name, chart.Namespace)
				if err != nil {
					return err
				}
				if !framework.GetHelmChartCondition(chart, v1.HelmChartFailed, corev1.ConditionTrue, "Unsupported version") {
					return fmt.Errorf("expected condition %v=%v not found", v1.HelmChartFailed, corev1.ConditionTrue)
				}
				return nil
			}, 120*time.Second).ShouldNot(HaveOccurred())
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a custom backoffLimit is specified", func() {
		var (
			err          error
			chart        *v1.HelmChart
			job          *batchv1.Job
			backOffLimit int32
		)
		BeforeAll(func() {
			backOffLimit = 10
			chart = framework.NewHelmChart("traefik-example-custom-backoff",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart.Spec.BackOffLimit = &backOffLimit
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should have correct job backOff Limit", func() {
			chart, err = framework.GetHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			job, err = framework.GetJob(chart)
			Expect(err).ToNot(HaveOccurred())
			Expect(*job.Spec.BackoffLimit).To(Equal(backOffLimit))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a no backoffLimit is specified", func() {
		var (
			err   error
			chart *v1.HelmChart
			job   *batchv1.Job
		)
		const (
			defaultBackOffLimit = int32(1000)
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-example-default-backoff",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should have correct job backOff Limit", func() {
			chart, err = framework.GetHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			job, err = framework.GetJob(chart)
			Expect(err).ToNot(HaveOccurred())
			Expect(*job.Spec.BackoffLimit).To(Equal(defaultBackOffLimit))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a custom podSecurityContext is specified", func() {
		var (
			err                        error
			chart                      *v1.HelmChart
			job                        *batchv1.Job
			expectedPodSecurityContext = &corev1.PodSecurityContext{
				RunAsNonRoot: ptr.To(false),
			}
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-example-custom-podsecuritycontext",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart.Spec.PodSecurityContext = &corev1.PodSecurityContext{
				RunAsNonRoot: ptr.To(false),
			}
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should have correct pod securityContext", func() {
			chart, err = framework.GetHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			job, err = framework.GetJob(chart)
			Expect(err).ToNot(HaveOccurred())
			Expect(*job.Spec.Template.Spec.SecurityContext).To(Equal(*expectedPodSecurityContext))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a no podSecurityContext is specified", func() {
		var (
			err                       error
			chart                     *v1.HelmChart
			job                       *batchv1.Job
			defaultPodSecurityContext = &corev1.PodSecurityContext{
				RunAsNonRoot: ptr.To(true),
				SeccompProfile: &corev1.SeccompProfile{
					Type: "RuntimeDefault",
				},
			}
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-example-default-podsecuritycontext",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should have correct pod securityContext", func() {
			chart, err = framework.GetHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())
			job, err = framework.GetJob(chart)

			Expect(err).ToNot(HaveOccurred())
			Expect(*job.Spec.Template.Spec.SecurityContext).To(Equal(*defaultPodSecurityContext))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a custom securityContext is specified", func() {
		var (
			err                     error
			chart                   *v1.HelmChart
			job                     *batchv1.Job
			expectedSecurityContext = &corev1.SecurityContext{
				AllowPrivilegeEscalation: ptr.To(true),
			}
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-example-custom-securitycontext",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart.Spec.SecurityContext = &corev1.SecurityContext{
				AllowPrivilegeEscalation: ptr.To(true),
			}
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should have correct container securityContext", func() {
			chart, err = framework.GetHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			job, err = framework.GetJob(chart)
			Expect(err).ToNot(HaveOccurred())
			Expect(*job.Spec.Template.Spec.Containers[0].SecurityContext).To(Equal(*expectedSecurityContext))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})

	Context("When a no securityContext is specified", func() {
		var (
			err                    error
			chart                  *v1.HelmChart
			job                    *batchv1.Job
			defaultSecurityContext = &corev1.SecurityContext{
				AllowPrivilegeEscalation: ptr.To(false),
				Capabilities: &corev1.Capabilities{
					Drop: []corev1.Capability{
						"ALL",
					},
				},
				ReadOnlyRootFilesystem: ptr.To(true),
			}
		)
		BeforeAll(func() {
			chart = framework.NewHelmChart("traefik-example-default-securitycontext",
				"stable/traefik",
				"1.86.1",
				"v3",
				"metrics:\n  prometheus:\n    enabled: true\nkubernetes:\n  ingressEndpoint:\n    useDefaultPublishedService: true\nimage: docker.io/rancher/library-traefik\n",
				map[string]intstr.IntOrString{
					"rbac.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
					"ssl.enabled": {
						Type:   intstr.String,
						StrVal: "true",
					},
				})
			chart, err = framework.CreateHelmChart(chart, framework.Namespace)
			Expect(err).ToNot(HaveOccurred())
		})
		It("Should create a release for the chart", func() {
			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(1))
		})
		It("Should have correct container securityContext", func() {
			chart, err = framework.GetHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			job, err = framework.GetJob(chart)
			Expect(err).ToNot(HaveOccurred())
			Expect(*job.Spec.Template.Spec.Containers[0].SecurityContext).To(Equal(*defaultSecurityContext))
		})
		AfterAll(func() {
			err = framework.DeleteHelmChart(chart.Name, chart.Namespace)
			Expect(err).ToNot(HaveOccurred())

			Eventually(func(g Gomega) {
				g.Expect(framework.GetHelmChart(chart.Name, chart.Namespace)).Error().Should(MatchError(apierrors.IsNotFound, "IsNotFound"))
			}, 120*time.Second, 5*time.Second).Should(Succeed())

			Eventually(framework.ListReleases, 120*time.Second, 5*time.Second).WithArguments(chart).Should(HaveLen(0))
		})
	})
})



================================================
FILE: test/suite/zz_suite_test.go
================================================
package suite_test

import (
	"testing"

	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
)

func TestSuite(t *testing.T) {
	RegisterFailHandler(Fail)
	RunSpecs(t, "Helm Suite")
}


